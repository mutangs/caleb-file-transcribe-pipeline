AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Caleb SQS-only Transcribe pipeline using EXISTING S3 buckets (eu-west-3 / Paris)

Globals:
  Function:
    Runtime: python3.11
    Timeout: 600
    MemorySize: 2048
    Architectures: [ x86_64 ]

Parameters:
  RawBucketName:
    Type: String
    Description: Existing S3 bucket for raw uploads (e.g., media-raw-caleb)
  AudioBucketName:
    Type: String
    Description: Existing S3 bucket for normalized audio (e.g., media-audio-caleb)
  TranscriptsBucketName:
    Type: String
    Description: Existing S3 bucket for transcripts (e.g., media-transcripts-caleb)

Resources:

  # SQS queues + DLQs
  RawDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: q-raw-caleb-dlq

  RawQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: q-raw-caleb
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt RawDLQ.Arn
        maxReceiveCount: 8
      VisibilityTimeout: 900

  AudioDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: q-audio-caleb-dlq

  AudioQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: q-audio-caleb
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt AudioDLQ.Arn
        maxReceiveCount: 8
      VisibilityTimeout: 300

  TranscriptsDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: q-transcripts-caleb-dlq

  TranscriptsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: q-transcripts-caleb
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt TranscriptsDLQ.Arn
        maxReceiveCount: 8
      VisibilityTimeout: 300

  # SQS queue policies (allow S3 to send from your existing buckets)
  RawQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues: [ !Ref RawQueue ]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowS3RawToSend
            Effect: Allow
            Principal: { Service: s3.amazonaws.com }
            Action: SQS:SendMessage
            Resource: !GetAtt RawQueue.Arn
            Condition:
              ArnEquals: { aws:SourceArn: !Sub 'arn:aws:s3:::${RawBucketName}' }

  AudioQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues: [ !Ref AudioQueue ]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowS3AudioToSend
            Effect: Allow
            Principal: { Service: s3.amazonaws.com }
            Action: SQS:SendMessage
            Resource: !GetAtt AudioQueue.Arn
            Condition:
              ArnEquals: { aws:SourceArn: !Sub 'arn:aws:s3:::${AudioBucketName}' }

  TranscriptsQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues: [ !Ref TranscriptsQueue ]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowS3TranscriptsToSend
            Effect: Allow
            Principal: { Service: s3.amazonaws.com }
            Action: SQS:SendMessage
            Resource: !GetAtt TranscriptsQueue.Arn
            Condition:
              ArnEquals: { aws:SourceArn: !Sub 'arn:aws:s3:::${TranscriptsBucketName}' }

  # FFmpeg Layer
  FFmpegLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: ffmpeg-static-caleb
      ContentUri: layer/
      CompatibleRuntimes: [ python3.11 ]
      RetentionPolicy: Retain

  # Lambda #1: converter
  ConvertFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: convert_on_upload_caleb
      CodeUri: src/convert_on_upload/
      Handler: app.handler
      Layers: [ !Ref FFmpegLayer ]
      Timeout: 600
      MemorySize: 3008          # <= fix: 3072 â†’ 3008
      EphemeralStorage: { Size: 4096 }
      Environment:
        Variables:
          OUTPUT_BUCKET: !Ref AudioBucketName
          FFMPEG_PATH: /opt/bin/ffmpeg
      Policies:
        - Statement:
            - Effect: Allow
              Action: [ 's3:GetObject' ]
              Resource: !Sub 'arn:aws:s3:::${RawBucketName}/*'
            - Effect: Allow
              Action: [ 's3:PutObject','s3:HeadObject','s3:GetObject' ]
              Resource: !Sub 'arn:aws:s3:::${AudioBucketName}/*'
      Events:
        RawQueueEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt RawQueue.Arn
            BatchSize: 1
            MaximumBatchingWindowInSeconds: 0

  # Lambda #2: start transcribe
  StartTranscribeFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: start_transcribe_on_audio_caleb
      CodeUri: src/start_transcribe_on_audio/
      Handler: app.handler
      Timeout: 180
      Environment:
        Variables:
          RESULT_BUCKET: !Ref TranscriptsBucketName
          RAW_PREFIX: raw/
          LANG_OPTIONS: en-US,en-GB,fr-FR,fr-CA
      Policies:
        - Statement:
            - Effect: Allow
              Action: [ 'transcribe:StartTranscriptionJob','transcribe:GetTranscriptionJob' ]
              Resource: '*'
            - Effect: Allow
              Action: [ 's3:PutObject' ]
              Resource: !Sub 'arn:aws:s3:::${TranscriptsBucketName}/*'
      Events:
        AudioQueueEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt AudioQueue.Arn
            BatchSize: 1
            MaximumBatchingWindowInSeconds: 0

  # Lambda #3: finalize to text
  FinalizeFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: finalize_to_text_caleb
      CodeUri: src/finalize_to_text/
      Handler: app.handler
      Timeout: 180
      Environment:
        Variables:
          RESULT_BUCKET: !Ref TranscriptsBucketName
          RAW_PREFIX: raw/
          FINAL_PREFIX: final/
          DELETE_JSON: true
      Policies:
        - Statement:
            - Effect: Allow
              Action: [ 's3:GetObject' ]
              Resource: !Sub 'arn:aws:s3:::${TranscriptsBucketName}/raw/*'
            - Effect: Allow
              Action: [ 's3:PutObject','s3:DeleteObject' ]
              Resource: !Sub 'arn:aws:s3:::${TranscriptsBucketName}/*'
      Events:
        TranscriptsQueueEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt TranscriptsQueue.Arn
            BatchSize: 1
            MaximumBatchingWindowInSeconds: 0

Outputs:
  RawQueueArn: { Value: !GetAtt RawQueue.Arn }
  AudioQueueArn: { Value: !GetAtt AudioQueue.Arn }
  TranscriptsQueueArn: { Value: !GetAtt TranscriptsQueue.Arn }
  RawQueueUrl: { Value: !Ref RawQueue }
  AudioQueueUrl: { Value: !Ref AudioQueue }
  TranscriptsQueueUrl: { Value: !Ref TranscriptsQueue }
